[{"id":0,"href":"/docs/%E5%BE%AE%E7%A7%AF%E5%88%86/","title":"微积分","section":"Docs","content":"\rIntroduction\r#\r"},{"id":1,"href":"/docs/%E5%8D%9A%E5%AE%A2/cachelab/","title":"Cache Lab","section":"博客","content":"\rCache实现\r#\rCache模拟器设计\r#\rCacheLab2\r#\r"},{"id":2,"href":"/docs/%E5%8D%9A%E5%AE%A2/cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Cpp学习笔记","section":"博客","content":"\rEffictive Cpp\r#\r1：让自己习惯C++\r#\r1st:View C++ as a federation of languages\r#\r2nd:Prefer consts,enums,and inlines to #defines\r#\r3rd:USe const whenever possible\r#\r4th:\r#\rCpp std\r#\r使用随机数生成器生成随机数\r#\r随机数生成器是随机数引擎类模板的一个预定义实例\n#include \u0026lt;random\u0026gt; #include \u0026lt;iostream\u0026gt; int main(){ std::random_device rd; for(size_t n {};n\u0026lt;8;++n){ std::cout\u0026lt;\u0026lt;rd()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } "},{"id":3,"href":"/docs/%E5%8D%9A%E5%AE%A2/effectivegit/","title":"Effective Git","section":"博客","content":"\rUse git pull \u0026ndash;rebase instead of git pull\r#\rGit commit semantic\r#\r人生苦短,请遵守规范\n提交细则\r#\r对于Git的提交日志，我们有非常明确而详细的提交规范。这将有助于我们在查看项目历史时，更容易明确每一次提交的内容。另一方面，我们还直接使用了Git提交日志来生成AngularJS的变更日志。\n修改类型\r#\r每个类型值都表示了不同的含义，类型值必须是以下的其中一个\nfeat : 提交新功能 fix : 修复了bug docs : 只修改了文档 style : 修改代码格式，未修改代码逻辑 refactor : 代码重构，既没修复bug也没有添加新功能 perf : 性能优化，提高性能的代码更改 test : 添加或修改代码测试 chore : 对构建流程或辅助工具和依赖库(如文档生成等)的更改 代码回滚\r#\r代码回滚比较特殊，如果本次提交是为了恢复到之前的某个提交，那提交消息应该以“revert:”开头，后跟要恢复到的那个提交的标题。然后在消息正文中，应该写上“This reverts commit ”，其中“”是要还原的那个提交的SHA值。\n标题\r#\r标题是对变更的简明描述\n使用祈使句和现代时态 不要大写首字母 结尾不要使用句号 如何拉取仓库并重命名\r#\r例如，如果你想将远程仓库克隆到一个名为 new-repo-name 的目录中，可以这样做：\ngit clone https://github.com/username/old-repo-name.git new-repo-name 这将把远程仓库克隆到一个新的目录 new-repo-name 中。\n"},{"id":4,"href":"/docs/%E5%8D%9A%E5%AE%A2/effectiveshell/","title":"Effective Shell","section":"博客","content":"\rEffective Power Shell\r#\r.ps1文件使用uft-8 with bom保存\n"},{"id":5,"href":"/docs/%E5%8D%9A%E5%AE%A2/scp%E5%91%BD%E4%BB%A4/","title":"Scp命令","section":"博客","content":"\rTITLE\r#\rscp -P 51521 -r root@47.96.157.89:/data/workspace/myshixun/ ./CacheLab2 "},{"id":6,"href":"/docs/%E5%8D%9A%E5%AE%A2/spark%E8%B8%A9%E5%9D%91/","title":"Spark踩坑","section":"博客","content":"\rSpark踩坑\r#\r无法执行\n"},{"id":7,"href":"/docs/%E5%BE%AE%E7%A7%AF%E5%88%86/%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E8%AE%A1%E7%AE%97/","title":"一元积分计算","section":"微积分","content":"hello world\n"},{"id":8,"href":"/docs/%E5%8D%9A%E5%AE%A2/%E4%BC%98%E9%9B%85%E7%9A%84hugo%E5%8D%9A%E5%AE%A2/","title":"优雅的Hugo博客","section":"博客","content":"\rgit仓库以及Github actions设置\r#\r插入图片\r#\r插入公式\r#\r代码块以及代码高亮\r#\r使用Front Matter\r#\r如何避免pdf在hugo项目里的重复拷贝\r#\r优雅地新建文章\r#\r使用hugo new -k替代hugo new "},{"id":9,"href":"/docs/%E5%8D%9A%E5%AE%A2/","title":"博客","section":"Docs","content":"\rhello world\r#\r@\n"},{"id":10,"href":"/docs/%E5%8D%9A%E5%AE%A2/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/","title":"大数据处理系统","section":"博客","content":"\r大数据处理系统\r#\r请分析大数据相关特征，包括数据体量大(Volume)、数据流动性高(Velocity)以及数据种类繁多(Variety)分别对大数据处理带来了什么具体挑战，并简要阐述相应措施。 答：挑战：设计高拓展性、低成本、快速响应的大数据存储和处理系统；数据种类多，需求多样，关联复杂；建模、存储、查询、分析和理解多样化的复杂数据，挖掘数据价值 ； 措施：1. 数据为中心的计算架构 2. 化繁为简，弱化数据一致性，提高可拓展性和可靠性\n复制与一致性：具有多副本的分布式存储系统，当一个节点的数据被修改时，还需要保持副本之间的一致性；通过数据读写的操作日志回放，能够实现主副本到备副本的增量复制；\n集群环境下多副本需要实现负载均衡，数据均匀分布，副本一致性。\nCAP涵义 1.一致性：要求系统保持数据一致；2.可用性：指系统处于可用状态；3.分区容忍性：在存在多个数据分区和数据分区发生变化的情况下，分布式系统仍然能够满足一致性和可用性\n向量钟是实现数据一致性的工具。使用向量钟可以捕获同一对象不同版本之间的因果关系，从而保证不同副本通过传递向量钟实现数据一致。向量钟是一个（节点，计数）的链表。计数器，初始为0，节点每次更新操作加1. Merkle树又称hash树，节点存储数据块的hash值，非叶节点存储对应子节点串联字符串的hash\nnvm成本较dram低，功耗、散热要求低、掉电存储不丢失。两者结合可以既获得dram优越的访问性能，又减小dram介质易失性和存储密度低的缺点。\n内存计算是以将数据装入内存中处理，进行避免I/O操作的一种新型的以数据为中心的并行计算模式。内存计算相比较于传统方式减少了磁盘io，大幅度提高了数据吞吐量和数据处理速度\nDynamo系统使用一致性哈希算法将数据分布到多个存储节点中。使用虚拟哈希环，每个物理节点分配多个虚拟token，来实现均匀分配\n函数式编程：函数是一等公民。特点：函数可以单独存在，可以作为参数或者返回值，无副作用。\n引用透明性：程序可自由的将表达式替换为它的值而不改变程序 高阶函数：函数可以不依赖任何其他对象而独立存在，可以作为参数传入另一个函数，可以作为函数返回值 函数柯里化：把接受多个参数的函数变成接受单一参数的函数，并且返回接受余下参数并返回结果的新函数 惰性求值：调用函数时，不是盲目地计算所有实参的值然后再进入函数体，而是先进入函数体，只有当需要实参值时才计算所需实参值。\nMapReduce是抽象并行编程模型，定义了map和reduce两个抽象的编程接口，实现基本的并行计算任务。两个函数的输入、输出以及中间结果都是\u0026lt;key,value\u0026gt;键值对的形式。\n//Map function map(){ return list{tunks}; } function reduce(){ sort (tunk) return tunk[...100]; } int main(){ res=info; while(res.length!=100){ tmp = map(res); for(i:tmp){ reduce(i) } } } 流处理系统的语义保障按照每个元组被完全处理的次数分为： 至多一次；系统保证在处理数据时，任意元组要么被刚好处理一次，要么被丢此，不会出现对同一元组的重复处理 至少一次；指系统能够保证处理数据时，任意元组都至少被处理一次不能丢失，但是允许同一元组被重复处理 恰好一次：指系统能够保障数据处理时，所有元组都恰好被处理一次，不存在元组被重复处理或者被丢弃的情况\nApache Storm是实时分布式流处理系统，从分布式系统或者分布式消息队列中获取源数据，并将元数据封装为元组，一条数据流就是一个无边界的tuple数据，这些tuple序列以分布式的方式创建和处理。Spark Streaming是spark api核心拓展，本质是典型的微处理系统，和以元组问单位进行流式处理不同，spark将无尽的数据流按时间切分成连续的小批次数据，然后用批处理方法处理，数据流按照时间片分隔开的离散流。\n以点为中心的编程模型：VC，pagerank，缺点是由于图内部结构依赖复杂，不易拓展，难以并行化，优点：点处理的并行度高，能容易的表示大部分图算法，缺点：存在对边的大量随机访存 以边为中心的编程模型：EC，bfs，优点：可以表示多种图算法，对边的访问时顺序的。缺点：存在对点的大量随机访问，存在对边的冗余计算。顺序访存占比高，性能好 以路径为中心的编程模型：与以边为中心的编程模型类似，采用顺序访存。包含分散（scatter）和整合（gather）操作。主节点通过迭代器对所有节点循环执行gather和scatter 以子图为中心的编程模型：粗粒度的编程模型，局部收敛促进全局收敛，减少收敛次数\nclass Edge: source:Vertex target:Vertex weight:float class Vertex: id:int state:Any class Graph: edges:List[Edge] vertex_states:Dict[int,Vertex] function initialize(graph,source_id): for each vertex in graph.vertex_states: if vertex.id == source_id: vertex.state = 0 else: vertex.state = infinity function scatter(edges,vertex_states): messages=[] for each edge in edges: source_state = vertex_states[edge.souce].state if source_state != infinity: message = source_state + edge.weight messages.append((edge.target,message)) return messages function gather(messages,vertex_states): for each(terget,message) in messages: current_state = vertex_states[target].state if message\u0026lt;current_state vertex_state[target].state=message function main_loop(graph,source_id,max_iterations): initialize(graph,source_id) for i in range(max_iterations): messages = scatter(graph.edges,graph.vertex_states) gather(messages,graph.vertex_states) if(convergence_reached(graph.vertex_states)): break A\u0026ndash;\u0026gt;B\u0026ndash;\u0026gt;A\u0026ndash;\u0026gt;B\n资源调度算法 FIFO：根据任务到达顺序将任务送到线性队列里，按照先进先出的顺序依次分配。设置多个队列，优先级不相同。 延迟调度算法：为了满足数据的局部性而采取的算法，因为分布式系统中计算和数据可能在不同地方，为了减小数据传输延迟，选择将计算移动到数据的位置 主资源公平调度算法 多资源打包调度算法 无私的资源调度算法\n并行任务在分布式缓存系统中调度的基本原则时使用更好的任务执行计划，作业更快时间完成。 存储优化解决小文件问题： HAR文件：在HDFS上构建分层文件系统，使用Hadoop archive命令构建，运行MapReduce作业，将要归档的文件打包成少量HDFS文件\n采用序列文件(SequenceFile)的格式：使用文件名作为Key，文件内容作为Value，将大量小文件存入序列文件，然后在序列文件上用流方式处理。\r将逻辑元数据管理负担部分转移到应用层\r相比于HAR，优点是降低了主控节点的计算负载，但小文件的逻辑存储层对于应用不透明。\r"},{"id":11,"href":"/docs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"操作系统","section":"Docs","content":"\rhello\r#\r"},{"id":12,"href":"/docs/%E5%8D%9A%E5%AE%A2/%E6%97%A5%E8%AE%B0/","title":"日记","section":"博客","content":"\r2024_05_05\r#\rBEGIN\r#\r2024_05_06\r#\rBEGIN\r#\r2024_05_07\r#\rBEGIN\r#\r2024_05_08\r#\rBEGIN\r#\r2024_05_09\r#\rBEGIN\r#\r2024_05_10\r#\rBEGIN\r#\r2024_05_11\r#\rBEGIN\r#\r2024_05_12\r#\rBEGIN\r#\r2024_05_13\r#\rBEGIN\r#\r2024_05_14\r#\rBEGIN\r#\r2024_05_15\r#\rBEGIN\r#\r2024_05_16\r#\rBEGIN\r#\r2024_05_17\r#\rBEGIN\r#\r2024_05_18\r#\rBEGIN\r#\r2024_05_19\r#\rBEGIN\r#\r2024_05_20\r#\rBEGIN\r#\rEND\r#\r2024_05_21\r#\rBEGIN\r#\rEND\r#\r2024_05_22\r#\rBEGIN\r#\r无事发生\nEND\r#\r2024_05_23\r#\r无事\n2024_05_24\r#\r2024_05_25\r#\r2024_05_26\r#\r补\n2024_05_27\r#\r倒计时209天\n"},{"id":13,"href":"/docs/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/","title":"系统结构","section":"Docs","content":"\r第一章\r#\rAmadhl定律\r#\r加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间 的百分比。\n系统加速比：\n$ T(加速比) = \\frac{系统性能(改进后) }{ 系统性能(改进前) } = \\frac{总执行时间(改进前)}{总执行时间(改进后)}$\n加速比依赖于两个因素：\n可改进比例 (Fe，Fraction of Execution time that is Enhanced): 在改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例。 (总是小于等于1) 部件加速比(Se，Speedup Efficiency)：可改进部分改进以后性能提高的倍数。它是改进前所需的执行时间与改进后执行时间的比。 改进后程序的总执行时间$T_n$\n$T_n = T_0(1-Fe+\\frac{Fe}{Se})$\n系统加速比$S_n$(改进前后总执行时间之比)\n$S_n=\\frac{T_0}{T_n}=\\frac{1}{(1-Fe)+\\frac{Fe}{Se}} $\nCPU时间\r#\r$CPU时间 = 执行程序所需的时间周期数 \\times 时间周期数$\n$时间周期数是系统时钟频率的倒数$\n$CPI(每条指令执行的平均时钟周期数量) = 时间周期数 / IC(执行的指令条数)$\n$CPU时间 = IC(指令条数) \\times CPI(指令平均时间周期数) \\times 时间周期时间$\nCPU的性能取决于三个参数：\n时间周期时间：取决于硬件实现技术和计算机组成 CPI(Cycles Per Instruction)：取决于计算机组成和指令系统的结构 IC(Instruction Count)：取决于指令系统的结构和编译技术 $ CPU时间周期数 = \\sum_{i=1}^n({CPI_i}{\\times}{IC_i} ) $\n$ CPU时间 = 执行程序所需时钟周期数 \\times 时钟周期时间 = \\sum_{i=1}^n({CPI_i} {\\times}{IC_i}) \\times 时间周期时间 $ $ CPI = \\frac{时钟周期数}{IC} = CPI * \\sum_{i=1}^n({\\frac{IC_i}{IC}}) $\nMIPS\r#\r每秒百万指令数\n第三章\r#\r单功能非线性流水线调度\r#\rIF：Instruction Fetch取指 ID：Instruction Decode解码 EX：Excute 执行 MEM：Memory Access 访存 WB：Write Back 写回 "},{"id":14,"href":"/docs/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","title":"线性代数","section":"Docs","content":"hello\n"}]